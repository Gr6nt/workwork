# คำตอบแลบ Big-O Time & Space Complexity

> เติมเฉพาะ **คำตอบและเหตุผลของคุณ** สำหรับแต่ละข้อ (ดูโจทย์ใน `README.md`).  
> ให้ตอบเป็น Big-O ของ **เวลา (Worst-case)** และ **พื้นที่ช่วย (Auxiliary Space)** พร้อมเหตุผลย่อ

---

## ข้อมูลผู้ส่ง
- ชื่อ – นามสกุล: ภูริทัตต์ เทอร์รี่ แกรนท์
- รหัสนักศึกษา: 1670704772
- เซกชัน: 227D

## เช็กลิสต์ก่อนส่ง
- [ ] อ่านโจทย์ครบทุกข้อใน `README.md`
- [ ] คำตอบระบุ Big-O และเหตุผลย่อในแต่ละข้อ
- [ ] ไฟล์นี้ชื่อ `answers/answers.md` และถูก push ขึ้นรีโพแล้ว

---

## แนวทางการให้เหตุผล (แนะนำ)
- อธิบายจำนวนรอบลูปหรือจำนวนการเรียกฟังก์ชันโดยประมาณ แล้วสรุปเป็น Big-O
- ระบุว่าสิ่งใดนับเป็น **พื้นที่ช่วย** (เช่น เซต/คิว/สแตก) และสิ่งใดคือน้ำหนักของอินพุต (ไม่นับ)
- หากมีกรณีพิเศษ ให้บอกสมมติฐานที่ใช้

---

## Problem 1 — Harmonic inner loop
**Time (worst-case):** `O(n log n)`  
**เหตุผลย่อ:n(1 + 1/2 + 1/3 + … + 1/n) ≈ n log n**  
- อธิบายผลรวมจำนวนรอบของลูปด้านในโดยขึ้นกับตัวแปร i ว่าประมาณเท่าไร จบด้วย Big-O

**Auxiliary Space:** `O(1)`  
**เหตุผลย่อ:มีแค่ตัวแปร n i j ไม่ได้สร้างโครงสร้างข้อมูลใหม่**  
- ระบุว่ามีตัวแปรช่วย/โครงสร้างข้อมูลเพิ่มหรือไม่

---

## Problem 2 — First duplicate ด้วยเซต
**Time (worst-case):** `O(n)` (สมมติแฮชเฉลี่ยดี)  
**เหตุผลย่อ:วน n ครั้ง, การตรวจและเพิ่มใน set = O(1) ต่อรอบ → Linear**  

**Auxiliary Space:** `O(n)`  
**เหตุผลย่อ:set อาจเก็บได้มากสุด n ค่า (กรณีไม่มีซ้ำ)**  

**หากห้ามใช้หน่วยความจำเพิ่มเกิน O(1):**  
- วิธี/แนวคิด: วิธี/แนวคิด: ใช้ brute force สองลูปเพื่อตรวจหาคู่ซ้ำ หรือ mark โดยตรงในอาเรย์
- เวลาอย่างน้อยที่ต้องใช้: `O(n^2)` และเหตุผลย่อ: ต้องเปรียบเทียบทุกตัวกับที่เหลือเพราะไม่มีโครงสร้างข้อมูลช่วย
---

## Problem 3 — Fibonacci แบบเรียกซ้ำ (โดยไม่มี memoization)
**Time (worst-case):** `O(2^n)`  
**เหตุผลย่อ:การเรียก fib(n) แตกเป็น fib(n-1) + fib(n-2) ต่อเนื่อง → จำนวนการเรียกโตแบบ binary tree ขนาด ~2^n → Exponential**  

**Auxiliary Space (ความลึกสแตก):** `O(n)`  
**เหตุผลย่อ:ความลึกของการเรียกซ้อน = n**  

> (ตัวเลือก) ถ้าใช้ **memoization/DP** เวลาและพื้นที่จะเป็นอย่างไร และเพราะเหตุใด?
เวลา = O(n) เพราะแต่ละค่า fib(k) คำนวณครั้งเดียว
พื้นที = O(n) ถ้าเก็บทุกค่า, หรือ O(1) ถ้า bottom-up เก็บเพียงสองค่าล่าสุด

## Problem 4 — 3-Sum ด้วย sort + two pointers
**Time (worst-case):** `O(n^2)`  
**เหตุผลย่อ:เรียงลำดับ O(n log n) + สองพอยน์เตอร์สำหรับทุก i = O(n²).
O(n²) ครอบ O(n log n) → Quadratic**  

**Auxiliary Space:**  
- ถ้า sort **in-place** (เช่น heapsort): `O(1)` — เหตุผล: ไม่ใช้บัฟเฟอร์พิเศษ
- ถ้า sort ต้องใช้บัฟเฟอร์ (เช่น mergesort/Timsort): `O(n)` — เหตุผล: ต้องใช้พื้นที่เก็บชั่วคราวขนาด n

---


## อ้างอิง/บันทึกเพิ่มเติม (ถ้ามี)
  Harmonic sum: Hₙ ≈ ln(n) → n log n
3-Sum แบบ two pointers เป็นวิธีมาตรฐานที่ดีที่สุดที่รู้ใน O(n²)
  Problem 1 = Linearithmic = O(n log n)
  Problem 2 = Linear = O(n)
  Problem 3 = Exponential = O(2^n)
  Problem 4 = Quadratic = O(n^2)
